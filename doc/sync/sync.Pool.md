# 临时对象池sync.Pool

> 可以作为保存临时取还对象的一个"池子", 可以用作针对某种数据的缓存,  Pool 里装的对象可以被无通知地被回收

`sync.Pool`属于结构体类型,他的值被使用后就不应该再被复制了
临时对象: 不需要持久使用的某一类值,对程序来说可有可无(有就使用,没有就创建)


## 作用

对于很多需要重复分配,回收内存的地方,`sync.Pool` 是一个很好的选择. 频繁地分配、回收内存会给 GC 带来一定的负担,严重的时候会引起 CPU 的毛刺，
而 `sync.Pool` 可以将暂时不用的对象缓存起来,待下次需要的时候直接使用,不用再次经过内存分配,`复用对象的内存`,`减轻 GC 的压力`,`提升系统的性能`

sync.Pool是协程安全的

## 使用场景

>  当多个 goroutine 都需要创建同⼀个对象的时候,如果 goroutine 数过多,导致对象的创建数⽬剧增,进⽽导致 GC 压⼒增大。
>  形成 "并发⼤－占⽤内存⼤－GC 缓慢－处理并发能⼒降低－并发更⼤"这样的恶性循环
>  在这个时候，需要有⼀个对象池，每个 goroutine 不再⾃⼰单独创建对象，⽽是从对象池中获取出⼀个对象(如果池中已经有的话)


## 为什么说临时对象池中的值会被及时地清理掉

因为 GoLang 运行时系统中的垃圾回收器,所以在每次开始执行之前,都会对所有已创建的临时对象池中的值进行全面地清除
`sync包`在被初始化的时候,会向 GoLang 运行时系统注册一个函数(`池清理函数`),这个函数的功能:清除所有已创建的临时对象池中的值.
在每次即将执行垃圾回收时就都会执行`池清理函数`

池汇总列表: sync包中还有一个包级私有的全局变量。这个变量代表了当前的程序中使用的所有临时对象池的汇总，它是元素型为`*sync.Pool`的切片



## 怎样保证一个临时对象池中总有比较充足的临时对象






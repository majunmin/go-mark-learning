# panic and recover

> 1. 在 Go 语言中，程序中一般是使用错误来处理异常情况。对于程序中出现的大部分异常情况，错误就已经够用了。
> 2. 但在有些情况，当程序发生异常时，无法继续运行.在这种情况下，我们会使用 panic 来终止程序.
>    当函数发生 panic 时，它会终止运行，在执行完所有的`延迟函数`后，程序控制返回到该函数的调用方.这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 panic 信息，接着打印出堆栈跟踪（Stack Trace），最后程序终止。
>
> panic + reciver 类似于其他语言的 try-catch-finally, goy语言里很好使用他们，尽量使用 error


## panic 什么时候使用

需要注意的是，你应该尽可能地使用错误，而不是使用 panic 和 recover。只有当程序不能继续运行的时候，才应该使用 panic 和 recover 机制。

1. 发生了一个不能恢复的错误，此时程序不能继续运行.
   一个例子就是 web 服务器无法绑定所要求的端口。在这种情况下，就应该使用 panic，因为如果不能绑定端口，啥也做不了。

2. 发生了一个编程上的错误. 
   假如我们有一个接收指针参数的方法，而其他人使用 nil 作为参数调用了它. 在这种情况下，我们可以使用 panic，因为这是一个编程错误：`用 nil 参数调用了一个只能接收合法指针的方法`。


## recover

> `recover` 是一个内建函数，用于重新获得 panic 协程的控制。
> 只有在延迟函数的内部，调用 recover 才有用, 而且 recover() 不能被其他函数嵌套，
> 在延迟函数内调用 recover，可以取到 panic 的错误信息，并且停止 panic 续发事件（Panicking Sequence），程序运行恢复正常。

## panic，recover 和 Go 协程

只有在相同Go协程里面调用 recover才有用，recover 不能恢复一个不同协程的 panic。







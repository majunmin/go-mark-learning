# 指针的有限操作


## Golang中那些值是不可寻址的

- 常量的值 
- 基本类型值的字面量
- 算术操作的结果值
- 对各种字面量的索引表达式和切片表达式的结果值,不过有一个例外,对切片字面量的索引结果值却是可寻址的
- 对字符串变量的索引表达式和切片表达式的结果值
- 对字典变量的索引表达式的结果值
- 函数字面量和方法字面量,以及对它们的调用表达式的结果值
- 结构体字面量的字段值,也就是对结构体字面量的选择表达式的结果值
- 类型转换表达式的结果值
- 类型断言表达式的结果值
- 接收表达式的结果值

### 不可变
### 临时结果
### 不安全的

> 1. 不可变的值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。
> 2. 绝大多数被视为临时结果的值都是不可寻址的。算术操作的结果值属于临时结果,针对值字面量的表达式结果值也属于临时结果。
>    但有一个例外,对**切片字面量的索引结果值虽然也属于临时结果,但却是可寻址的**.
> 3. 若拿到某值的指针可能会破坏程序的一致性,那么就是不安全的,该值就不可寻址。由于字典的内部机制,对字典的索引结果值的取址操作都是不安全的。另外,获取由字面量或标识符代表的函数或方法的地址显然也是不安全的
> 


## 通过 `unsafe.Pointer`如何操作可寻址的 值

`unsafe.Pointer`是像`*Dog`类型的值这样的指针值和`uintptr`值之间的桥梁

1. 一个`指针值`(比如*Dog类型的值)可以被转换为一个`unsafe.Pointer`类型的值，反之亦然
2. 一个`uintptr`类型的值也可以被转换为一个`unsafe.Pointer`类型的值,反之亦然
3. 一个`指针值`无法被直接转换成一个`uintptr`类型的值,反之亦然

`unsafe.Offsetof`函数用于获取两个值在内存中的起始存储地址之间的`偏移量`,以字节为单位.



